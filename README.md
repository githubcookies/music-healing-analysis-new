# 音乐治愈性分析工具 (Music Healing Analysis Tool)

这是一个基于Python的音乐治愈性分析工具，通过分析音乐的多个声学特征来评估音乐的治愈特性。该工具结合了传统音乐理论和现代声学分析方法，为音乐的治愈性提供全面的量化评估。

## 功能特点

- 多维度分析：包括音程亲和力、声音粗糙度和频谱特征分析
- 科学的评分体系：基于音乐理论和声学原理的评分标准
- 多线程处理：支持并行处理多个音频文件
- 可视化分析：自动生成评分分布图表
- 全面的数据导出：支持Excel格式的详细分析报告
- 支持多种音频格式：MP3, WAV, FLAC, M4A
- 单文件分析：支持对单个音频文件进行独立分析

## 安装要求

1. Python 3.8+
2. 依赖包安装：
```bash
pip install -r requirements.txt
```

## 使用方法

### 1. 批量分析模式

1. 准备音频文件：
   - 创建 `healing_music` 文件夹：存放治愈音乐样本
   - 创建 `non_healing_music` 文件夹：存放非治愈音乐样本

2. 运行批量分析：
```bash
python music_analysis.py
```

### 2. 单文件分析模式

提供两种方式分析单个音频文件：

#### 方式一：命令行参数（推荐）

直接在命令行中指定音频文件路径：
```bash
python analyze_single_audio.py "你的音频文件路径"
```

示例：
```bash
python analyze_single_audio.py "D:\音乐文件\示例音乐.mp3"
```

#### 方式二：交互式输入（现在程序直接运行似乎有bug，不推荐采用这种方式，用命令行方法就好）

1. 启动程序：
```bash
python analyze_single_audio.py
```

2. 按提示输入音频文件路径：
   - 可以直接将音频文件拖拽到命令行窗口
   - 或手动输入完整路径
   - 输入 'q' 或 'quit' 退出程序

#### 分析报告说明

程序将输出详细的分析报告，包括：

1. 总体治愈得分（0-100分）
2. 三个维度的详细得分：
   - 音程亲和力得分
   - 声音粗糙度得分
   - 频谱特征得分
3. 每个维度的评估说明
4. 整体评价和建议

示例输出：
```
==================================================
音频文件分析报告: 示例音乐.mp3
==================================================

总体治愈得分: 75.32/100
------------------------------

详细评分:
1. 音程亲和力得分: 82.45/100
   - 评估音乐的和声协和度
   - 较高分数表示音程关系更和谐

2. 声音粗糙度得分: 70.18/100
   - 评估音乐的平滑度
   - 较高分数表示声音更柔和平顺

3. 频谱特征得分: 73.33/100
   - 评估音色和频率分布
   - 较高分数表示音色更纯净、频率分布更合理

得分解释:
该音频具有一定的治愈特性，整体表现良好
==================================================
```

## 评分系统详解

### 1. 音程亲和力分数 (Consonance Score)

音程亲和力分数基于传统音乐理论中的协和度概念，采用精确的权重系统进行计算。

#### 1.1 音程权重系统

##### 完全协和音程（权重：正向最强）
| 音程 | 半音数 | 权重 | 说明 |
|------|--------|------|------|
| 纯一度 | 0 | 1.0 | 最完美的协和音程 |
| 纯八度 | 12 | 1.0 | 与纯一度同等重要 |
| 纯五度 | 7 | 0.9 | 次重要的完全协和音程 |
| 纯四度 | 5 | 0.8 | 基础的完全协和音程 |

##### 不完全协和音程（权重：正向中等）
| 音程 | 半音数 | 权重 | 说明 |
|------|--------|------|------|
| 大三度 | 4 | 0.6 | 主要的不完全协和音程 |
| 小三度 | 3 | 0.5 | 次要的不完全协和音程 |
| 大六度 | 9 | 0.4 | 较弱的不完全协和音程 |
| 小六度 | 8 | 0.3 | 最弱的不完全协和音程 |

##### 不协和音程（权重：负向）
| 音程 | 半音数 | 权重 | 说明 |
|------|--------|------|------|
| 大二度 | 2 | -0.2 | 轻微的不协和 |
| 小二度 | 1 | -0.4 | 明显的不协和 |
| 增四度/减五度 | 6 | -0.6 | 最不协和的音程 |
| 小七度 | 10 | -0.3 | 中等的不协和 |
| 大七度 | 11 | -0.5 | 强烈的不协和 |

#### 1.2 计算流程

1. 音高提取
   - 使用librosa.piptrack进行音高检测
   - 参数设置：
     * 最低频率：C2音（65.41 Hz）
     * 最高频率：C7音（2093 Hz）
     * 阈值：0.1（降低噪声影响）

2. 音程序列生成
   - 将频率转换为MIDI音符号
   - 计算相邻音符的音程差
   - 过滤异常值（限制在两个八度内）

3. 权重计算
   - 将音程映射到一个八度内（模12运算）
   - 查表获取对应权重
   - 计算平均权重

4. 分数归一化
   - 输入：原始权重均值（范围：-0.6到1.0）
   - 输出：0-100的分数范围
   - 公式：score = (weight - min_weight) / (max_weight - min_weight) * 100

### 2. 粗糙度分数 (Roughness Score)

粗糙度分析通过评估音频的多个声学特征来衡量音乐的平滑度。

#### 2.1 特征提取与计算

1. 频谱质心分析（20%权重）
   - 计算：librosa.feature.spectral_centroid
   - 评估音色的"亮度"
   - 得分计算：1 - (mean(centroid) / (sr/4))
   - 较低的质心值表示更柔和的音色

2. 频谱带宽分析（20%权重）
   - 计算：librosa.feature.spectral_bandwidth
   - 评估频率分布的集中度
   - 得分计算：1 - (mean(bandwidth) / (sr/4))
   - 较窄的带宽表示更纯净的音色

3. 谐波-打击乐分离（40%权重）
   - 使用HPSS算法分离谐波和打击乐成分
   - 计算谐波能量比：harmonic_energy / (harmonic_energy + percussive_energy)
   - 较高的谐波比表示更柔和的音色

4. 音高稳定性分析（20%权重）
   - 基于色谱图特征（chroma features）
   - 计算色谱变化的方差
   - 得分计算：1 - min(chroma_variance, 1)
   - 较低的方差表示更稳定的音高变化

#### 2.2 最终分数计算

1. 特征组合
```python
roughness_score = (
    harmonic_ratio * 0.4 +
    centroid_score * 0.2 +
    bandwidth_score * 0.2 +
    chroma_score * 0.2
)
```

2. Sigmoid变换
```python
final_score = 1 / (1 + np.exp(-8 * (roughness_score - 0.5)))
```

### 3. 频谱特征分数 (Spectral Score)

频谱特征分析通过评估音频的频域特征来衡量音乐的声音质量。

#### 3.1 特征计算

1. 梅尔频谱图分析
   - 使用librosa.feature.melspectrogram
   - 转换为分贝刻度：librosa.power_to_db

2. 频谱质心计算
   - 评估音色的整体"重心"
   - 归一化：相对于采样率的一半

3. 频谱带宽计算
   - 评估频率分布的离散程度
   - 归一化：相对于采样率的四分之一

4. 频谱熵计算
   - 评估频谱的复杂度
   - 归一化：相对于最大可能熵

#### 3.2 分数组合

最终的频谱特征分数通过以下权重组合：
```python
spectral_score = (
    0.4 * centroid_score +
    0.3 * bandwidth_score +
    0.3 * entropy_score
)
```

### 4. 最终治愈性分数计算

总分通过加权平均的方式组合各个维度的分数：

```python
final_score = (
    0.4 * roughness_score +
    0.3 * consonance_score +
    0.3 * spectral_score
)
```

最后应用sigmoid变换使得分布更加合理：
```python
transformed_score = 100 / (1 + np.exp(-0.15 * (final_score - 65)))
```

## 输出结果

程序会生成以下文件：

1. `analysis_results.xlsx`
   - 包含所有音频文件的详细分析数据
   - 各个维度的原始分数和最终得分
   - 文件信息和处理状态

2. `score_distributions.png`
   - 四个子图显示不同维度的分数分布
   - 治愈音乐和非治愈音乐的对比直方图
   - 使用不同颜色区分两类音乐

## 注意事项

1. 音频质量要求
   - 建议使用采样率≥44.1kHz的音频
   - 时长建议≥30秒
   - 避免使用过度压缩的音频

2. 性能考虑
   - 多线程处理可能占用较多CPU资源
   - 建议批量处理时控制并发数量

3. 结果解释
   - 分数仅供参考，不应作为唯一评判标准
   - 建议结合专业音乐知识解释结果

## 许可证

MIT License

## 贡献指南

欢迎通过以下方式贡献：
1. 提交Issue报告问题
2. 提交Pull Request改进代码
3. 完善文档和示例

## 作者

[Xiong hr]

## 致谢

感谢所有为项目提供建议和帮助的贡献者。



